import random
import numpy as np
import sys

def lorenz(x, y, z, s=10, r=28, b=2.667):
    x_dot = s*(y - x)
    y_dot = r*x - y - x*z
    z_dot = x*y - b*z
    return x_dot, y_dot, z_dot

#three dimensional code, but only 2d system so z = 0
def vanderpol(x, y, z, a=1.5, mu=1):
#    print(x, y, z)
    x_dot = y
    y_dot = -x + mu*y*(a-x*x)
    z_dot = 0
    return x_dot, y_dot, z_dot

def dist(x, y):
    s = 0
    for i in range(len(x)):
        s += (x[i]-y[i])**2
    return s**0.5

def varzero(x0, y0, z0, **kwargs): #same kwargs as gen_series
    """
    computes variance with number of points at initial start
    RETURNS: list of [xyz] variances at each "point step"
    """
    if(kwargs['npts'] == 0):
        return False #fake variance for when generating other tracks
    res = []
    for i in range(kwargs['npts']):
        xn = x0 + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        yn = y0 + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        zn = z0 + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        keywords = kwargs
        keywords['npts'] = 0
        keywords['multires']=False
        res.append(gen_series(xn, yn, zn, retVar = False, **keywords))
    var = [[], [], []] #x, y, z
    for i in range(kwargs['totalStep']):
        tmp = [[], [], []]
        for j in res:
            tmp[0].append(j[i][0])  
            tmp[1].append(j[i][1])
            tmp[2].append(j[i][2])
        var[0].append(np.var(tmp[0]))
        var[1].append(np.var(tmp[1]))
        var[2].append(np.var(tmp[2]))
    return var

def varAt(x, y, z, **kwargs):
    """
    computes variance with number of points at every time point
    RETURNS three numbers: varx, vary, varz
    """
    if(kwargs['npts'] == 0):
        return False #fake variance for when generating other tracks
    var = [[], [], []]
    for i in range(kwargs['npts']):
        xn = x + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        yn = y + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        zn = z + random.random()*kwargs['pbC']-kwargs['pbC']/2.0
        xd, yd, zd = kwargs['series'](xn, yn, zn)
        var[0].append(xd)
        var[1].append(yd)
        var[2].append(zd)
    return np.var(var[0]), np.var(var[1]), np.var(var[2])

def gen_series(x0, y0, z0, logData = False, retVar = True, **kwargs):
    if(logData):
        f = open(str(sys.argv[3]) + "data.log", "a+")
        f.write(str(x0) + " " + str(y0) + " " + str(z0) + " " + str(kwargs) + "\n")
    
    """
    kwargs contains
    'dstT',\ #distance between points 
    'totalStep',\ #total number of steps
    'varzero' = True,\ #if variance is calcuated from zeroth time step or every timestep 
    'pbC' = 0.05,\ #range for pertubations of variance
    'npts' = 200,\ # number of variance points to simulate
    'multires' = False,\ #if true then use 'dstT'/variacne for 'multires'olution
    series=lorenz #series to produce

    RETURNS: list of lists (points and xyz variances if specified)
    """           
    
    dt = 1e-2 #"highest" resolution
    stepCnt = 1 #stepcounter
    
    pt = [[x0, y0, z0]]#list of points generated
    pGen = [x0, y0, z0]#last point generated by high res
    varLst = [[0,0,0]]#list of variances produced

    if(kwargs['varzero']):
        var = varzero(x0, y0, z0, **kwargs)
    else:
        var = False #sample at every step instead

    dst = 0
    lastVar = 1
    tSum = 0
    # Stepping through "time".
    while(stepCnt < kwargs['totalStep']):
        dot = [0,0,0]
        dot[0], dot[1], dot[2] = kwargs['series'](pGen[0], pGen[1], pGen[2])

        for i in range(3):
            pGen[i] += dot[i]*dt
        dst += dist(pGen, [pGen[0]-dot[0]*dt, pGen[1]-dot[1]*dt, pGen[2]-dot[2]*dt])
#        print(pGen)
#        print([pGen[0]-dot[0]*dt, pGen[1]-dot[1]*dt, pGen[2]-dot[2]*dt])
        #'multires'
        testVal = (kwargs['dstT']/lastVar) if kwargs['multires'] else kwargs['dstT']
#        print(dst, dot)
        if(dst >= testVal):
            tSum += dst
            pt.append([pGen[0], pGen[1], pGen[2]])

            if(var == False):
#                print(kwargs)
                varx, vary, varz = varAt(pGen[0], pGen[1], pGen[2], **kwargs)
            else:
                varx, vary, varz = var[stepCnt-1][0], var[stepCnt-1][1], var[stepCnt-1][2]

            lastVar = max((varx**2 + vary**2 + varz**2)**0.5, 0.2) #limit how long this distance can go (15 units)
            varLst.append([varx, vary, varz])
            dst = 0
            stepCnt += 1
    if(logData):
        f.write("variance list\n")
        f.write(str(varLst) + "\n")
    #normalization
    pt = np.add(-1*np.min(pt), pt)
    pt = np.dot(1/np.max(pt), pt)
    #save the sequence for training
    xss = []; yss = []; zss = []
    vx = []; vy = []; vz = []
#    print(len(pt), len(varLst))
    for i in range(len(pt)):
        xss.append(pt[i][0])
        yss.append(pt[i][1])
        zss.append(pt[i][2])
        vx.append(varLst[i][0])
        vy.append(varLst[i][1])
        vz.append(varLst[i][2])
    if(retVar):
        series = np.transpose(np.vstack((xss,yss,zss,vx,vy,vz)))
    else:
        series = np.transpose(np.vstack((xss,yss,zss)))
    if(logData):
        f.write("series produced\n")
        f.write(str(series) + "\n")
        f.write("\n")
        f.close()
    
    return series

def rrange():
    return random.random()*0.4-0.2

if __name__ == "__main__":
    print("running as main")
    res = []
    for iter in range(1000):
        if(iter%10 == 0):
            print(iter)
        keywords = {'dstT':0.6, 'totalStep':int(sys.argv[1]), 'varzero':False, 'pbC':0.05, 'npts':200, 'multires':False, 'series':vanderpol}
        a = gen_series(rrange(), rrange(), 0, logData=True, retVar = True, **keywords)
        tA = []
        for i in a:
            tA.append(i)
        res.append(tA)

    np.save("data/lorenz.npy", np.array(res))
